---
title: "Interactive risk scaling of entry points"
format:
  html:
    echo: false
    code-fold: true
    toc: false
    theme: cosmo
    html-math-method: mathjax
    page-layout: custom
    grid:
      sidebar-width: 300px
      body-width: 1200px
      margin-width: 0px
vignette: >
  %\VignetteIndexEntry{Interactive risk scaling of entry points}
  %\VignetteEngine{quarto::html}
  %\VignetteEncoding{UTF-8}
---

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>

```{=html}
<style>
.quarto-title {
  margin-bottom: 20px;
}

.grid-container {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  grid-template-rows: repeat(2, 1fr);
  gap: 15px;
  height: calc(100vh - 200px);
  margin-top: 15px;
}

.plot-container {
  background: white;
  border-radius: 5px;
  box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
  padding: 10px;
  display: flex;
  flex-direction: column;
  height: 100%;
}

.plot-title {
  font-weight: bold;
  margin-bottom: 5px;
}

.plot-content {
  flex: 1;
  min-height: 0;
}

.parameter-display {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
  margin: 15px 0;
  padding: 10px;
  background: white;
  border-radius: 5px;
}

.math-container {
  background: white;
  padding: 8px;
  border-radius: 5px;
  margin-top: 5px;
  text-align: center;
}

.intro-text {
  margin-bottom: 20px;
}
</style>
```

## Introduction {.intro-text}

This document demonstrates an interactive visualization of a mathematical function with multiple parameters. The function is defined as:

$$f(x_c, x_u) = m \cdot s(s^{-1}(s(\alpha \cdot x_c) / \lambda) + \beta \cdot x_u)$$

Where $s(x)$ is a sigmoid function defined as:

$$s(x) = \frac{1 - e^{-x}}{1 + e^{-x}}$$

And $s^{-1}(y)$ is its inverse:

$$s^{-1}(y) = \ln\left(\frac{y+1}{1-y}\right)$$



::: {.panel-sidebar}


## Parameter Controls

```{ojs}
viewof m = Inputs.range([1, 100], {value: 100, step: 1, label: "m:"})
viewof alpha = Inputs.range([0.1, 10], {value: 1, step: 0.1, label: "α (alpha):"})
viewof beta = Inputs.range([0.1, 10], {value: 1, step: 0.1, label: "β (beta):"})
viewof lambda = Inputs.range([1, 10], {value: 3, step: 0.1, label: "λ (lambda):"})
```

```{ojs}
// Display current parameter values
html`<div class="parameter-display">
  <div><strong>m = </strong>${m}</div>
  <div><strong>α = </strong>${alpha.toFixed(2)}</div>
  <div><strong>β = </strong>${beta.toFixed(2)}</div>
  <div><strong>λ = </strong>${lambda.toFixed(2)}</div>
</div>`
```

## Mathematical Expressions

**Equivalent number of uncontrolled entry points:**

::: {.math-container}
$\frac{s^{-1}(s(\alpha \cdot x_c) / \lambda)}{\beta}$
:::

**Univariate risk scaling:**

::: {.math-container}
$m \cdot s(\beta \cdot x)$
:::

:::

::: {.panel-fill}

```{=html}
<div class="grid-container">
  <div class="plot-container">
    <div class="plot-title">Scaling function (2D Heatmap)</div>
    <div class="plot-content" id="heatmap-plot"></div>
  </div>
  <div class="plot-container">
    <div class="plot-title">Scaling function (3D Surface)</div>
    <div class="plot-content" id="surface-plot"></div>
  </div>
  <div class="plot-container">
    <div class="plot-title">Equivalent number of uncontrolled entry points</div>
    <div class="plot-content" id="entry-points-plot"></div>
  </div>
  <div class="plot-container">
    <div class="plot-title">Univariate risk scaling</div>
    <div class="plot-content" id="risk-scaling-plot"></div>
  </div>
</div>
```

```{ojs}
// Define the sigmoid function s(x) and its inverse
s = function(x) {
  const expNegX = Math.exp(-x);
  return (1 - expNegX) / (1 + expNegX);
}

sInverse = function(y) {
  // Ensure y is in the valid range (-1, 1)
  if (y >= 1 || y <= -1) {
    return 0; // Return 0 for invalid inputs
  }
  return Math.log((y + 1) / (1 - y));
}

// Main function f(xc, xu)
f = function(xc, xu) {
  try {
    const alphaXc = alpha * xc;
    const sAlphaXc = s(alphaXc);
    const sAlphaXcOverLambda = sAlphaXc / lambda;
    
    // Ensure the value is in valid range for sInverse
    if (sAlphaXcOverLambda >= 1 || sAlphaXcOverLambda <= -1) {
      return 0;
    }
    
    const sInverseValue = sInverse(sAlphaXcOverLambda);
    const betaXu = beta * xu;
    const sum = betaXu + sInverseValue;
    return m * s(sum);
  } catch (error) {
    return 0; // Return 0 for invalid inputs
  }
}

// Function for "Equivalent number of uncontrolled entry points"
entryPointsFunction = function(xc) {
  try {
    const sAlphaXc = s(alpha * xc);
    const sAlphaXcOverLambda = sAlphaXc / lambda;
    
    // Ensure the value is in valid range for sInverse
    if (sAlphaXcOverLambda >= 1 || sAlphaXcOverLambda <= -1) {
      return 0;
    }
    
    return sInverse(sAlphaXcOverLambda) / beta;
  } catch (error) {
    return 0; // Return 0 for invalid inputs
  }
}

// Function for "Univariate risk scaling"
riskScalingFunction = function(x) {
  return m * s(beta * x);
}
```

```{ojs}
// Generate data for the heatmap
generateHeatmapData = {
  const xcValues = Array.from({length: 40}, (_, i) => i * 0.1);
  const xuValues = Array.from({length: 40}, (_, i) => i * 0.1);
  
  // Create a 2D array for z values
  const zValues = [];
  
  // For each xu value (y-axis)
  for (let i = 0; i < xuValues.length; i++) {
    const xu = xuValues[i];
    const row = [];
    
    // For each xc value (x-axis)
    for (let j = 0; j < xcValues.length; j++) {
      const xc = xcValues[j];
      try {
        row.push(f(xc, xu));
      } catch {
        row.push(0);
      }
    }
    
    zValues.push(row);
  }
  
  return {
    xcValues,
    xuValues,
    zValues
  };
}

// Generate data for entry points curve
generateEntryPointsData = {
  const xcPointsValues = Array.from({length: 100}, (_, i) => i * 0.04);
  const entryPointsValues = xcPointsValues.map(xc => {
    try {
      return entryPointsFunction(xc);
    } catch {
      return 0;
    }
  });
  
  return {
    xcPointsValues,
    entryPointsValues
  };
}

// Generate data for risk scaling curve
generateRiskScalingData = {
  const xValues = Array.from({length: 100}, (_, i) => i * 0.04);
  const riskValues = xValues.map(x => riskScalingFunction(x));
  
  return {
    xValues,
    riskValues
  };
}
```



```{ojs}
// Create and update all plots
{
  // Get data
  const heatmapData = generateHeatmapData;
  const entryPointsData = generateEntryPointsData;
  const riskScalingData = generateRiskScalingData;
  
  // Create heatmap plot
  const heatmapPlotData = [{
    z: heatmapData.zValues,
    x: heatmapData.xcValues,
    y: heatmapData.xuValues,
    type: 'heatmap',
    colorscale: 'Viridis'
  }];
  
  const heatmapLayout = {
    margin: { t: 5, r: 5, b: 40, l: 60 },
    xaxis: {
      title: 'xc',
      range: [0, 4],
      scaleanchor: 'y',
      scaleratio: 1
    },
    yaxis: {
      title: 'xu',
      range: [0, 4],
      autorange: false
    },
    coloraxis: { colorbar: { title: 'f(xc, xu)' } },
    autosize: true
  };
  
  // Create surface plot
  const surfacePlotData = [{
    z: heatmapData.zValues,
    x: heatmapData.xcValues,
    y: heatmapData.xuValues,
    type: 'surface',
    colorscale: 'Viridis',
    contours: {
      z: {
        show: true,
        usecolormap: true,
        highlightcolor: "#fff",
        project: { z: true }
      }
    }
  }];
  
  const surfaceLayout = {
    margin: { t: 5, r: 5, b: 5, l: 5 },
    scene: {
      xaxis: { title: 'xc', range: [0, 4] },
      yaxis: { title: 'xu', range: [0, 4] },
      zaxis: { title: 'f(xc, xu)' },
      camera: {
        eye: { x: 1.5, y: -1.5, z: 1 }
      },
      aspectratio: { x: 1, y: 1, z: 0.7 }
    },
    autosize: true
  };
  
  // Create entry points plot
  const entryPointsPlotData = [{
    x: entryPointsData.xcPointsValues,
    y: entryPointsData.entryPointsValues,
    type: 'scatter',
    mode: 'lines',
    line: { color: 'rgb(31, 119, 180)', width: 3 }
  }];
  
  const entryPointsLayout = {
    margin: { t: 5, r: 5, b: 40, l: 50 },
    xaxis: {
      title: 'xc',
      range: [0, 4]
    },
    yaxis: { title: 'Entry Points Value' },
    autosize: true
  };
  
  // Create risk scaling plot
  const riskScalingPlotData = [{
    x: riskScalingData.xValues,
    y: riskScalingData.riskValues,
    type: 'scatter',
    mode: 'lines',
    line: { color: 'rgb(214, 39, 40)', width: 3 }
  }];
  
  const riskScalingLayout = {
    margin: { t: 5, r: 5, b: 40, l: 50 },
    xaxis: {
      title: 'x',
      range: [0, 4]
    },
    yaxis: { title: 'Risk Value' },
    autosize: true
  };
  
  // Render all plots
  window.Plotly.newPlot('heatmap-plot', heatmapPlotData, heatmapLayout);
  window.Plotly.newPlot('surface-plot', surfacePlotData, surfaceLayout);
  window.Plotly.newPlot('entry-points-plot', entryPointsPlotData, entryPointsLayout);
  window.Plotly.newPlot('risk-scaling-plot', riskScalingPlotData, riskScalingLayout);
  
  // Make plots responsive
  window.addEventListener('resize', function() {
    window.Plotly.relayout('heatmap-plot', {autosize: true});
    window.Plotly.relayout('surface-plot', {autosize: true});
    window.Plotly.relayout('entry-points-plot', {autosize: true});
    window.Plotly.relayout('risk-scaling-plot', {autosize: true});
  });
  
}
```

:::
